#!/usr/bin/python3

import fileinput, sys, math, csv, operator
import xy2path                     ## X+Y -> 1D fractal distance mapping; table

## pass X,Y in 2-column CSV, [0.0 .. 1.0]
##
## table in xy2path.tTABLE[] MUST have been generated by 2D/fractal generator
## it is indexed 0..2^N in both dimensions


##--------------------------------------
## returns array of <x, y> pairs
## no normalization etc., beyond range checking
##
def table_read(fname, field=1):
	csvf = open(fname, newline='')
	rd   = list(csv.reader(csvf, delimiter=',', quotechar='\\'))
	res  = []

	for fi, fields in enumerate(rd):
		if len(fields) < 2:
			raise ValueError("missing primary/secondary+value " +
			                 f"columns (line {fi +1})")
		try:
			x, y = float(fields[0]), float(fields[1])
		except ValueError:
			raise ValueError("malformed input: "+
			                 f"[{fields[0]},{fields[1]}]")

		if not (0.0 <= x <= 1.0):
			raise ValueError(f"X out of range {x} (line {fi +1})")
		if not (0.0 <= y <= 1.0):
			raise ValueError(f"Y out of range {y} (line {fi +1})")

		res.append([x, y])

	return res


##--------------------------------------
def terminate(msg):
	sys.stderr.write(msg +'\n')
	sys.exit(-1)


##--------------------------------------
def usage():
	terminate("""
	Route 2D paths through space-filling functions
	Usage: [MAXN==...]  ... <name of input CSV containing X+Y coordinates>
	...usage blurb comes here...
	""")


##--------------------------------------
## works both for [x, y] (0.0 .. 1.0) and [x, y, x', y'] (2x2, incl. normalized)
##
def dumppath(p):
	print('\n'.join(f'{v[0]} {v[1]}' for v in p))


##--------------------------------------
## returns 2x floats normalized to [0 .. 2^N]
##
## TODO: check square table during reading
##
def xy2tablexy(x, y, table):
	"normalize [0.0 .. 1.0] coordinates to [0 .. 2^N] dimensions"

	xi, yi = x * len(table), y * len(table)

	return xi, yi, table[ round(xi) ][ round(yi) ]


##----------------------------------------------------------------------------
if __name__ == '__main__':
	sys.argv.pop(0)
	if [] == sys.argv:
		usage()

	xys = table_read(sys.argv[0])
	xys = list([x, y, xy2tablexy(x, y, xy2path.tTABLE)[0],
	                  xy2tablexy(x, y, xy2path.tTABLE)[1],
	                  xy2tablexy(x, y, xy2path.tTABLE)[2],]
	           for x,y in xys)

	print("# initial=")
	for p in xys:
		print(f'# {p[2]},{p[3]}')
	print()

	print("sorted=")
	for p in sorted(xys, key=operator.itemgetter(4)):
		print(f'{p[2]},{p[3]}')
	print()

