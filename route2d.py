#!/usr/bin/python3

import fileinput, sys, math, csv, operator
import xy2path                     ## X+Y -> 1D fractal distance mapping; table

## pass X,Y in 2-column CSV, [0.0 .. 1.0]
##
## table in xy2path.tTABLE[] MUST have been generated by 2D/fractal generator
## it is indexed 0..2^N in both dimensions


##--------------------------------------
## returns array of <x, y> pairs
## no normalization etc., beyond range checking
##
def table_read(fname, field=1):
	csvf = open(fname, newline='')
	rd   = list(csv.reader(csvf, delimiter=',', quotechar='\\'))
	res  = []

	for fi, fields in enumerate(rd):
		if len(fields) < 2:
			raise ValueError("missing primary/secondary+value " +
			                 f"columns (line {fi +1})")
		try:
			x, y = float(fields[0]), float(fields[1])
		except ValueError:
			raise ValueError("malformed input: "+
			                 f"[{fields[0]},{fields[1]}]")

		if not (0.0 <= x <= 1.0):
			raise ValueError(f"X out of range {x} (line {fi +1})")
		if not (0.0 <= y <= 1.0):
			raise ValueError(f"Y out of range {y} (line {fi +1})")

		res.append([x, y])

	return res


##--------------------------------------
def terminate(msg):
	sys.stderr.write(msg +'\n')
	sys.exit(-1)


##--------------------------------------
def usage():
	terminate("""
	Route 2D paths through space-filling functions
	Usage: [MAXN==...]  ... <name of input CSV containing X+Y coordinates>
	...usage blurb comes here...
	""")


##--------------------------------------
## works both for [x, y] (0.0 .. 1.0) and [x, y, x', y'] (2x2, incl. normalized)
##
def dumppath(p):
	print('\n'.join(f'{v[0]} {v[1]}' for v in p))


##--------------------------------------
## returns 2x floats normalized to [0 .. 2^N], plus curve-distance(x,y)
##
## TODO: check square table during reading
##
def xy2tablexy(x, y, table):
	"normalize [0.0 .. 1.0] coordinates to [0 .. 2^N] dimensions"

	xi, yi = x * len(table), y * len(table)

	return xi, yi, table[ round(xi) ][ round(yi) ]


##--------------------------------------
## filter list to unique, valid indexes, preserving order
##
def idxs2table(maxn, iarr):
	return list(i  for i in iarr  if ((i >= 0) and (i <= maxn)))


##--------------------------------------
def xy2dist(xy1, xy2):
	return math.sqrt((xy1[0] - xy2[0]) **2 + (xy1[1] - xy2[1]) **2)


##--------------------------------------
## any array-of-tuples input with (x, y...) start is acceptable
## route is not closed: excludes loop-completing edge
##
def route2dists(xys):
	return (xy2dist(xys[i], xys[i+1])  for i in range(len(xys)-1))


##--------------------------------------
## any array-of-tuples input with (x, y...) start is acceptable
## route is not closed: excludes loop-completing edge
##
def route2total(xys):
	return sum(route2dists(xys))


##--------------------------------------
## tolerates, silently ignoring negative indexes
## repeated entries are counted only once
##
def idx2bitmask(arr):
	return sum((1 << v)  for v in set(arr)  if (v >= 0))


##----------------------------------------------------------------------------
## incremental swap costs, exchanging [i] and [j]:
##   ---[i-1]-------[i]-------[i+1]---
##           \     /   \     /
##             \ /       \ /         
##              =         =         
##             / \       / \ 
##           /     \   /     \
##   ---[j-1]-------[j]-------[j+1]---
##                      d(X, Y) == distance(X .. Y)
##   swap [i] and [j]:
##      - removes  d(i-1, i) +d(i, i+1)
##      - removes  d(j-1, j) +d(j, j+1)
##      - adds     d(i-1, j) +d(j, i+1)
##      - adds     d(j-1, i) +d(i, j+1)


##--------------------------------------
## find swaps which may be performed simultaneously and reduce total
## route length the most: swap position of points [i] and [j]
##
## returns list of index pairs to swap
##         None  no improvement found during any of the swaps
##
## 'swaps' stores [index1, index2, bitmask(all affected indexes)]
## we can hypothetically swap all length-reducaing candidates which do not
## overlap (therefore the bitmasks)
##
def swap1(xys, dists=None, dist=None):
	if dist == None:
		dist = route2total(xys)

	if dists == None:
		dists = list(route2dists(xys))

	swaps, best, dist0 = [], 0.0, dist

	for i in range(1, len(xys)-3):
		for j in range(i+1, len(xys)-2):
			ii = idxs2table(len(xys)-1, [i-1, i, i+1])
			ji = idxs2table(len(xys)-1, [j-1, j, j+1])

			print(f"## {i},{j} {ii},{ji}")

			rem =  xy2dist(xys[ i   ], xys[ i+1 ])
			rem += xy2dist(xys[ j-1 ], xys[ j   ])
			if (i):
				rem += xy2dist(xys[ i-1 ], xys[ i   ])
			if (j < len(xys)-1):
				rem += xy2dist(xys[ j   ], xys[ j+1 ])

			add =  xy2dist(xys[ j   ], xys[ i+1 ])
			add += xy2dist(xys[ j-1 ], xys[ i   ])
			if (i):
				add += xy2dist(xys[ i-1 ], xys[ j   ])
			if (j < len(xys)-1):
				add += xy2dist(xys[ i   ], xys[ j+1 ])

			if (add -rem < best):
				if False:
					print(f'# {i}: {xys[i  ][0]},{xys[i  ][1]}')
					print(f'#   +1 {xys[i+1][0]},{xys[i+1][1]}')
					print(f'# {j}: {xys[j][0]},{xys[j][1]}')
				print(f'# {i}x{j} +{add:.04f} -{rem:.04f} ' +
				      f'bal={add-rem:.06f}')
				sys.stdout.flush()

				add -= rem

				swaps.append([i, j,
				              idx2bitmask([i-1, i, i+1,
				                           j-1, j, j+1]),
				              add])
				best = add

		## swaps[-1] is the current-best pair
		## check if any preceding swap pairs might be simultaneously
		## applied (their bitmasks do not overlap)
		##
		## need not be optimal here: leaving any un-swapped here will
		## still get considered in the next iteration.  therefore,
		## simply scanning backwards and collating all bitmasks
		## ('swapbm') without further filtering, is sufficient

	if swaps == []:
		return None

	swaps  = list(sorted(swaps, key=operator.itemgetter(2)))
	pairs, swapbm = [], 0

		## pick up pairs in decreasing-improvement order
		## ...if the new swap does not conflict with any
		## already accepted one
		##
	for x, y, bm, diff in reversed(swaps):
		if (swapbm & bm):
			continue
		swapbm |= bm
		pairs.append([x, y])
		print(f"## SWAP+ {x} {y}")

	return pairs


##--------------------------------------
## find reorders which improve total path lengths: moving [i] to
## to after [j] and before [j+1]
##
## returns list of index pairs to reorder, [i, j] tuples
##         None  no improvement found during any of the swaps
##
## 'swaps' stores [index1, index2, bitmask(all affected indexes)]
## we can hypothetically swap all length-reducaing candidates which do not
## overlap (therefore the bitmasks)
##
def reorder1(xys, dist=None):
	if dist == None:
		dist = route2total(xys)
	res, dist0 = [], dist

	xl = xys[:]

	for i in range(len(xl) -1):
		for j in range(i, len(xl)):
			continue
			xys[i], xys[j] = xys[j], xys[i]
			d = route2total(xl)

			if (d < dist):
				print(f"# {i},{j} {dist:.6f}->{d:.6f}")
				sys.stdout.flush()

				res.append([i, j,
				            idx2bitmask([i-1, i, i+1,
				                         j-1, j, j+1]),
				            dist -d])
				dist = d

			xys[i], xys[j] = xys[j], xys[i]

		## res[-1] is the current-best pair
		## check if any preceding swap pairs might be simultaneously
		## applied (their bitmasks do not overlap)
		##
		## need not be optimal here: leaving any un-swapped here will
		## still get considered in the next iteration.  therefore,
		## simply scanning backwards and collating all bitmasks
		## ('swapbm') without further filtering, is sufficient

	if res == []:
		return None
	return None

	pairs, swapbm = [ [res[-1][0], res[-1][1]], ], res[-1][2]
	for x, y, bm, diff in res[:-1]:
		if (swapbm & bm):
			continue

		swapbm |= bm
		pairs.append([x, y])
		print(f"## SWAP+ {x} {y}")

	if (dist > dist0):
		raise InternalError("Swaps increasing overall cost")
			## ...in case we messed up loop+replacement above

		## TODO: need to re-eval after set of swaps
	print(f'## DIST= {dist0}->{dist}')

	return pairs


##----------------------------------------------------------------------------
if __name__ == '__main__':
	sys.argv.pop(0)
	if [] == sys.argv:
		usage()

	xys = table_read(sys.argv[0])
	xys = list([x, y, xy2tablexy(x, y, xy2path.tTABLE)[0],
	                  xy2tablexy(x, y, xy2path.tTABLE)[1],
	                  xy2tablexy(x, y, xy2path.tTABLE)[2],]
	           for x,y in xys)

	print("# INITIAL=")
	for p in xys:
		print(f'# {p[2]},{p[3]}')
	print()

			## initial plan: assign on curve
	xys = list(sorted(xys, key=operator.itemgetter(4)))

	round, dist0 = 0, route2total(xys)
	dist = dist0

	print(f"# SORTED.ROUND={round}")
	print(f"# DIST0={ dist }")
	print(f"# DIST={ 100.0* dist / dist0 :.02f}%")
	##
	for p in xys:
		print(f'{p[2]},{p[3]}')
	print()

	while True:
		imprd, round = 0, round +1

		swaps = swap1(xys, None)

		if swaps != None:
			i, j = swaps[0][0], swaps[0][1]

			print(f"##SWAP1.ROUND={round}")
			for i, j in swaps:
				print(f"##SWAP {i},{j}")
				xys[i], xys[j] = xys[j], xys[i]
				imprd += 1
			for p in xys:
				print(f'{p[2]},{p[3]}')
			print()
			sys.stdout.flush()

		swaps = reorder1(xys)
		if swaps != None:
			i, j = swaps[0][0], swaps[0][1]

			print(f"##SWAP1.ROUND={round}")
			for i, j in swaps:
				print(f"##SWAP {i},{j}")
				xys[i], xys[j] = xys[j], xys[i]
				imprd += 1
			for p in xys:
				print(f'{p[2]},{p[3]}')
			print()
			sys.stdout.flush()

		if imprd == 0:
			break

		if round > 10:
			break                 ## XXX

