#!/usr/bin/python3

import fileinput, sys, math, csv, operator
import xy2path                     ## X+Y -> 1D fractal distance mapping; table

## pass X,Y in 2-column CSV, [0.0 .. 1.0]
##
## table in xy2path.tTABLE[] MUST have been generated by 2D/fractal generator
## it is indexed 0..2^N in both dimensions


##--------------------------------------
## returns array of <x, y> pairs
## no normalization etc., beyond range checking
##
def table_read(fname, field=1):
	csvf = open(fname, newline='')
	rd   = list(csv.reader(csvf, delimiter=',', quotechar='\\'))
	res  = []

	for fi, fields in enumerate(rd):
		if len(fields) < 2:
			raise ValueError("missing primary/secondary+value " +
			                 f"columns (line {fi +1})")
		try:
			x, y = float(fields[0]), float(fields[1])
		except ValueError:
			raise ValueError("malformed input: "+
			                 f"[{fields[0]},{fields[1]}]")

		if not (0.0 <= x <= 1.0):
			raise ValueError(f"X out of range {x} (line {fi +1})")
		if not (0.0 <= y <= 1.0):
			raise ValueError(f"Y out of range {y} (line {fi +1})")

		res.append([x, y])

	return res


##--------------------------------------
def terminate(msg):
	sys.stderr.write(msg +'\n')
	sys.exit(-1)


##--------------------------------------
def usage():
	terminate("""
	Route 2D paths through space-filling functions
	Usage: [MAXN==...]  ... <name of input CSV containing X+Y coordinates>
	...usage blurb comes here...
	""")


##--------------------------------------
## works both for [x, y] (0.0 .. 1.0) and [x, y, x', y'] (2x2, incl. normalized)
##
def dumppath(p):
	print('\n'.join(f'{v[0]} {v[1]}' for v in p))


##--------------------------------------
## returns 2x floats normalized to [0 .. 2^N], plus curve-distance(x,y)
##
## TODO: check square table during reading
##
def xy2tablexy(x, y, table):
	"normalize [0.0 .. 1.0] coordinates to [0 .. 2^N] dimensions"

	xi, yi = x * len(table), y * len(table)

	return xi, yi, table[ round(xi) ][ round(yi) ]


##--------------------------------------
def xy2dist(xy1, xy2):
	return math.sqrt((xy1[0] - xy2[0])**2 + (xy1[1] - xy2[1])**2)


##--------------------------------------
## any array-of-tuples input with (x, y...) start is acceptable
## route is not closed: excludes loop-completing edge
##
def route2dist(xys):
	return sum(xy2dist(xys[i-1], xys[i])  for i in range(1, len(xys)))


##--------------------------------------
## tolerates, silently ignoring negative indexes
##
def idx2bitmask(arr):
	return sum((1 << v)  for v in arr  if (v >= 0))


##--------------------------------------
## find swaps which may be performed simultaneously and reduce total
## route length the most
##
## returns list of index pairs to swap
##         None  no improvement
##
## 'swaps' stores [index1, index2, bitmask(all affected indexes)]
## we can hypothetically swap all length-reducaing candidates which do not
## overlap (therefore the bitmasks)
##
def swap1(xys):
	dist = route2dist(xys)
	swaps, dist0 = [], dist

	for i in range(len(xys) -1):
		for j in range(i, len(xys)):
			xys[i], xys[j] = xys[j], xys[i]
			d = route2dist(xys)

			if (d < dist):
				print(f"# {i},{j} {dist:.6f}->{d:.6f}")
				sys.stdout.flush()

				swaps.append([i, j,
				              idx2bitmask([i-1, i, i+1,
				                           j-1, j, j+1]),
				              dist -d])
				dist = d

			xys[i], xys[j] = xys[j], xys[i]

		## swaps[-1] is the current-best pair
		## check if any preceding swap pairs might be simultaneously
		## applied (their bitmasks do not overlap)
		##
		## need not be optimal here: leaving any un-swapped here will
		## still get considered in the next iteration.  therefore,
		## simply scanning backwards and collating all bitmasks
		## ('swapbm') without further filtering, is sufficient

	if swaps == []:
		return None

	pairs, swapbm = [ [swaps[-1][0], swaps[-1][1]], ], swaps[-1][2]
	for x, y, bm, diff in swaps[:-1]:
		if (swapbm & bm):
			continue

		swapbm |= bm
		pairs.append([x, y])
		print(f"## SWAP+ {x} {y}")

	if (dist > dist0):
		raise InternalError("Swaps increasing overall cost")
			## ...in case we messed up loop+replacement above

		## TODO: need to re-eval after set of swaps
	print(f'## DIST= {dist0}->{dist}')

	return pairs


##----------------------------------------------------------------------------
if __name__ == '__main__':
	sys.argv.pop(0)
	if [] == sys.argv:
		usage()

	xys = table_read(sys.argv[0])
	xys = list([x, y, xy2tablexy(x, y, xy2path.tTABLE)[0],
	                  xy2tablexy(x, y, xy2path.tTABLE)[1],
	                  xy2tablexy(x, y, xy2path.tTABLE)[2],]
	           for x,y in xys)

	print("# INITIAL=")
	for p in xys:
		print(f'# {p[2]},{p[3]}')
	print()

			## initial plan: assign on curve
	xys = list(sorted(xys, key=operator.itemgetter(4)))

	round, dist0 = 0, route2dist(xys)
	dist = dist0

	print(f"# SORTED.ROUND={round}")
	print(f"# DIST0={ dist }")
	print(f"# DIST={ 100.0* dist / dist0 :.02f}%")
	##
	for p in xys:
		print(f'{p[2]},{p[3]}')
	print()

	while True:
		round += 1
		swaps = swap1(xys)
		if swaps == None:
			break

		i, j = swaps[0][0], swaps[0][1]

		print(f"##SWAP.ROUND={round}")
		for i, j in swaps:
			print(f"##SWAP {i},{j}")
			xys[i], xys[j] = xys[j], xys[i]
		for p in xys:
			print(f'{p[2]},{p[3]}')
		print()
		sys.stdout.flush()

